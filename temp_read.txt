  const prevPhase = currentNode._galPhase || 0;
  const newPhase = prevPhase + dPhi;
  currentNode._galPhase = newPhase;

  // Visual glow target
  const segs = currentNode.segments || 12;
  const segIndex = Math.floor(((newPhase + (ap.spokeRotate||0)) % (Math.PI*2)) / ((Math.PI*2)/segs));
  currentNode.segmentIndex = segIndex;
  currentNode.lastGlowSeg = segIndex;
  currentNode.lastGlowAt = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

  if (!barOk) return true; // bar gate

  // Delegate actual harmonic triggering to the Circle-of-Fifths engine
  // Force single-note behavior by temporarily zeroing chord probability
  const apBefore = currentNode.audioParams || {};
  const prevProb = apBefore.randomChordProbability;
  const prevIntensity = apBefore.pulseIntensity;
  apBefore.randomChordProbability = 0; // single notes

  // Trigger for each rotating dot crossing a stationary spoke
  const maxPerTick = Math.min(8, Math.max(1, Math.floor(dots.length / 4)));
  let count = 0;
  const mod = (x) => ((x % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);
  
  // For each dot, check if it crossed any spoke
  for (let d = 0; d < dots.length; d++) {
    if (count >= maxPerTick) break;
    const dot = dots[d];
    
    // Calculate dot angle at previous and current phase (dots rotate)
    const dotA0 = dot.baseAngle + (ap.globalOffset || 0) + dot.speed * prevPhase;
    const dotA1 = dot.baseAngle + (ap.globalOffset || 0) + dot.speed * newPhase;
    const dot0 = mod(dotA0);
    const dot1 = mod(dotA1);
    
    // Check if this dot crossed any spoke
    for (let s = 0; s < spokes; s++) {
      if (ap.spokeEnabled && ap.spokeEnabled[s] === false) continue;
      
      // Spoke is stationary
      const spokeAngle = mod(ap.spokeAngles ? ap.spokeAngles[s] : ((ap.spokeRotate || 0) + s * stepAngle));
      
      // Check if rotating dot crossed this stationary spoke
      const crossed = dot1 >= dot0 ? (spokeAngle > dot0 && spokeAngle <= dot1) : (spokeAngle > dot0 || spokeAngle <= dot1);
      
      if (crossed) {
        // probability gate per crossing
        const p = Math.max(0, Math.min(1, apBefore.noteProbability ?? 1));
        if (Math.random() > p) continue;
        
        // intensity
        const vmin = Math.max(0, Math.min(1, apBefore.velMin ?? 0.6));
        const vmax = Math.max(vmin, Math.min(1, apBefore.velMax ?? 1.0));
        const vel = vmin + Math.random() * (vmax - vmin);
        apBefore.pulseIntensity = vel;
        
        // Each dot can have its own musical content - for now use dot index to vary the note
        // Map dot index to degree bucket for different harmonic content per dot
        const dotSegment = d % segs;
        currentNode.segmentIndex = dotSegment;
        handleCircleFifthsPulse(currentNode, incomingConnection, deps);
        count++;
        break; // Only trigger once per dot per tick
      }
    }
  }
  apBefore.randomChordProbability = prevProb;
  apBefore.pulseIntensity = prevIntensity;
  return true;
}

export function rebuildGalacticDots(node) {
  buildDots(node);
}

// Continuous rotation update: advances phase every frame and triggers on spoke crossings
export function updateGalacticBloom(node, deltaTime, deps, { audioActive = true, secondsPerBeat = 0, isGlobalSyncEnabled = false, subdivisionOptions = [] } = {}) {
  if (!node || node.type !== GALACTIC_BLOOM_TYPE) return;
  const ap = node.audioParams || {};
  if (!Array.isArray(node._galDots)) buildDots(node);
  const dots = node._galDots || [];
  const spokes = Math.max(1, Math.floor(ap.numSpokes || 3));
  if (!Array.isArray(node._spokeGlow) || node._spokeGlow.length !== spokes) {
    node._spokeGlow = Array(spokes).fill(0);
  }
  if (!Array.isArray(ap.spokeEnabled) || ap.spokeEnabled.length !== spokes) {
    ap.spokeEnabled = Array(spokes).fill(true);
  }
  if (!Array.isArray(ap.spokeAngles) || ap.spokeAngles.length !== spokes) {
    const arr = [];
    const step = (Math.PI * 2) / spokes;
    for (let i = 0; i < spokes; i++) arr.push(((-Math.PI / 2 + i * step + (ap.spokeRotate||0)) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2));
    ap.spokeAngles = arr;
  }
  const stepAngle = (Math.PI * 2) / spokes; // used as fallback for activeSeg only
  let spinRPS = Math.max(0, ap.spinRPS ?? 0.25);
  if (isGlobalSyncEnabled && !ap.ignoreGlobalSync && ap.spinSyncEnabled) {
    // Custom rotation options for galactic bloom
    const galacticRotationOptions = [
      { label: "1/16", value: 0.25 },
      { label: "1/8", value: 0.5 },
      { label: "1/5", value: 0.8 },
      { label: "1/4", value: 1 },
      { label: "1/3", value: 4/3 },
      { label: "1/2", value: 2 },
      { label: "1", value: 4 },
      { label: "2", value: 8 },
      { label: "3", value: 12 },
      { label: "4", value: 16 },
      { label: "5", value: 20 },
      { label: "6", value: 24 },
      { label: "7", value: 28 },
      { label: "8", value: 32 },
      { label: "9", value: 36 },
      { label: "10", value: 40 }
    ];
    const idx = Math.max(0, Math.min(galacticRotationOptions.length - 1, ap.galacticRotationIndex ?? 3));
    const rotBeats = galacticRotationOptions[idx] && typeof galacticRotationOptions[idx].value === 'number' ? galacticRotationOptions[idx].value : 4; // default 4 beats/rotation
    if (secondsPerBeat > 0 && rotBeats > 0) {
      spinRPS = 1 / (secondsPerBeat * rotBeats);
    }
  }
  const speedScale = Math.max(0.05, Math.min(4, ap.spinSpeedScale ?? 1));
  const dPhi = 2 * Math.PI * (spinRPS * speedScale) * Math.max(0, deltaTime);
  if (dPhi <= 0) return;

  const prevPhase = node._galPhase || 0;
  const newPhase = prevPhase + dPhi;
  node._galPhase = newPhase;

  // Visual glow target (do not flash every frame; set time only on crossings)
  const segs = node.segments || 12;
  const segIndex = Math.floor(((newPhase + (ap.spokeRotate || 0)) % (Math.PI * 2)) / ((Math.PI * 2) / segs));
  node.segmentIndex = segIndex;

  if (!audioActive) return; // only visualize when transport paused

  // Trigger for each dot crossing a spoke between prevPhase and newPhase
  const prevProb = ap.randomChordProbability;
  ap.randomChordProbability = 0; // single notes
  const segAngle = (Math.PI * 2) / segs;
  let count = 0;
  const maxPerTick = Math.min(12, Math.max(1, Math.floor(dots.length / 3)));
  const mod = (x) => ((x % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);
  const nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  
  // For each rotating dot, check if it crossed any stationary spoke
  for (let d = 0; d < dots.length; d++) {
    if (count >= maxPerTick) break;
    const dot = dots[d];
    
    // Calculate dot angle at previous and current phase (dots rotate)
    const dotA0 = dot.baseAngle + (ap.globalOffset || 0) + dot.speed * prevPhase;
    const dotA1 = dot.baseAngle + (ap.globalOffset || 0) + dot.speed * newPhase;
    const dot0 = mod(dotA0);
    const dot1 = mod(dotA1);
    
    let crossedSpoke = null;
    // Check if this rotating dot crossed any stationary spoke
    for (let s = 0; s < spokes; s++) {
      if (ap.spokeEnabled[s] === false) continue;
      
      // Spoke is stationary
      const spokeAngle = mod(ap.spokeAngles ? ap.spokeAngles[s] : ((ap.spokeRotate || 0) + s * (Math.PI * 2) / spokes));
      
      // Check if rotating dot crossed this stationary spoke
      const crossed = dot1 >= dot0 ? (spokeAngle > dot0 && spokeAngle <= dot1) : (spokeAngle > dot0 || spokeAngle <= dot1);
      
      if (crossed) {
        crossedSpoke = { spokeIndex: s, angle: spokeAngle };
        break; // Use first crossed spoke
      }
    }
    
    if (crossedSpoke) {
      // probability
      const p = Math.max(0, Math.min(1, ap.noteProbability ?? 1));
      if (Math.random() > p) continue;
      
      // intensity
      const vmin = Math.max(0, Math.min(1, ap.velMin ?? 0.6));
      const vmax = Math.max(vmin, Math.min(1, ap.velMax ?? 1.0));
      const vel = vmin + Math.random() * (vmax - vmin);
      const prevIntensity = ap.pulseIntensity;
      ap.pulseIntensity = vel;
      
      // Each dot has its own musical content - use melodic pattern for note progression
      const selectedPattern = MELODIC_PATTERNS[ap.melodicPattern] || MELODIC_PATTERNS.ascending;
      const numDots = dots.length;
      
      // Get note from melodic pattern - this determines the harmonic progression/melody
      const dotSegment = selectedPattern.getNote(d, numDots);
      node.segmentIndex = dotSegment;
      node.lastGlowSeg = node.segmentIndex;
      node.lastGlowAt = nowMs;
      if (Array.isArray(node._spokeGlow)) node._spokeGlow[crossedSpoke.spokeIndex] = nowMs;
      
      try {
        // Trigger directly through the Circle-of-Fifths engine (single-note)
